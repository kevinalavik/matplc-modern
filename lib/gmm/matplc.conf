#
# sample matplc.conf configuration file
#


#   G E N E R A L   S Y N T A X
#   ===========================
#
# (name,value) pairs:
# name = value
#
# tables:
# table_name value_1_1 value_1_2 value_1_3 ...
# table_name value_2_1 value_2_2 value_2_3 ...
# ...
#
#
# tables and names are divided into sections.
# (Jiri, do you think you can come up with some good sentences
#  explainig how sections work, and how modules look for parameters
#  in sections named after their module_name ??)
# Should also explain how #includes are supported, and that it is protected
# against circular includes.
#
#
# NOTES:
#  (1)  when value is an integer, it may usually be written in
#       hexadecimal (0xF45A), octal (0172132) or decimal (62554) formats.  
#
#  (2)  when value or a name is a string with white space charatcters, it 
#       must be enclosed within "  ("this is a single value")



[PLC]
launch pid1 ../logic/dsp/dsp


[PLC]
#
#   T h e   P L C   s e c t i o n
#   =============================
#
#
# The PLC section is used to configure parameters related to the PLC, and
# are used by all modules. Some other parameters related to the PLC, but
# module specific, must be specified under those modules' sections.
#
# name = value pairs:
# ------------------
# confmap_key   = xxx : The key to use for the confmap shared memory. This is
#                       actually the same parameter configured through
#                       --PLCplc_id=xxx. The command line argument takes
#                       precedence over the value configured in this file.
#                       If this parameter is not specified either way, the
#                       default value DEF_CONFMAP_KEY (currenty = 23) is used.
#                       Valid values go from 0..INT_MAX. If 0 is specified,
#                       then a random key is chosen.
#
# globalmap_key = xxx : The key to use for the globalmap shared memory segment.
#                       If no value is specified, then the default 
#                       DEF_GLOBALMAP_KEY is used (currently = 0). Valid values
#                       go from 0..INT_MAX. If 0 is specified, then a random
#                       key is chosen.
#
# sem_key       = xxx : The key to use for the globalmap semaphore set used by
#                       the CMM. If no value is specified, then the default
#                       DEF_SEM_KEY is used (currently = 0). Valid values
#                       go from 0..INT_MAX. If 0 is specified, then a random
#                       key is chosen.
#
# confmap_pg    = xxx : The size of the confmap given in number of memory pages.
#                       If this value is left unspecified, the default value 
#                       DEF_CONFMAP_PG (currently = 2) is used.
#                       The size of each memory page is given by PAGE_SIZE
#                       defined in asm/page.h or sys/user.h (which is the
#                       correct include?) (for linux on intel (?) PAGE_SIZE
#                       is 4 kBytes).
#
# globalmap_pg  = xxx : The size of the globalmap given in number of memory 
#                       pages. If this value is left unspecified, the default
#                       value DEF_CONFMAP_PG (currently = 2) is used.
#
#
# tables:
# ------
# point      : defines the named points in the plc. See further down for syntax.
# point_alias: defines aliases to the named points in the plc. See further 
#              down for syntax.
#
#
#
# The POINT table
# ---------------
# syntax:
# point name "full name" owner at offset[.bit] [length]
#
# where:
# point     = 'point' identifier
# name      = Name used to search for point in plc_pt_by_name()
# full name = More extensive description of the point
#             This information is not loaded into the confmap of the plc
# owner     = Name of the module with write permission on the point
# at        = 'at' identifier
# offset    = location of word in the globalmap that holds the point's state
# bit       = the bit, in the word, that holds the point's state. This is 
#             optional, defaulting to 0.
# length    = the size in bits of the point. The point must not overflow
#             onto the next offset position (i.e. (bit + length) < 
#             (8*sizeof (u32)). The length is optional, defaulting to 32
#             if bit is not explicitly defined, and 1 otherwise.
#
#
# the POINT_ALIAS table
# ---------------------
# syntax:
# point_alias name "full name" org_name [bit [length]]
#
# where:
# point_alias = 'point_alias' identifier
# name        = Name used to search for point in plc_pt_by_name()
# full name = More extensive description of the point
#             This information is not loaded into the confmap of the plc
# bit       = The first bit, of the original point, that this alias will 
#             reference. This is optional, defaulting to 0.
# length    = the size in bits of the point. The point must not overflow
#             outside the original point (i.e. (bit + length) < 
#             (length of org_name point). The length is optional, defaulting
#             to the length of the org_name point if no bit is explicitly
#             specified, and 1 otherwise.
#
# note:
# (1) offset, bit and length may be written in hexadecimal (0xF45A),
#     octal (0172132) or decimal (62554) formats.
#

[PLC]
confmap_key = 15   # if not present defaults to DEF_PLC_ID (currently 23)
globalmap_key = 0  # if not present defaults to random key (globalmap_key = 0)
sem_key = 0        # if not present defaults to random key (sem_key = 0)
confmap_pg = 2     # if not present defaults to DEF_CONFMAP_PG   (currently=2)
globalmap_pg = 2   # if not present defaults to DEF_GLOBALMAP_PG (currently=2)

[PLC]
point P0.0  "full name 0.0" TEST at  0.0
point P0.1  "full name 0.1" TEST at  0.1 5
point P0.8  "full name 0.8" TEST at  0.8      # defaults to 0.8  1
point P0.3  "full name 0.3" TEST at  0.3      # ERROR! overlaps P0.1
point P1.0  "full name 1.0" TEST at  1        # defaults to 1.0 32
point P2.0  "full name 2.0" TEST at  2    16  # defaults to 2.0 16

[PLC]
point_alias A0 "full name A0" P0.0            # defaults to P0.0 0 1
point_alias A1 "full name A1" P0.1            # defaults to P0.1 0 5
point_alias A2 "full name A2" P0.1 2          # defaults to P0.1 2 1
point_alias A3 "full name A3" P0.1 2 2
point_alias A4 "full name A4" P0.1 2 4        # ERROR! overflows outside of P0.1



[module_name]
#
#  P L C   r e l a t e d   v a l u e s
#  ===================================
#
#  PLC related values, specific to each module.
#
# name = value pairs:
# ------------------
# location = sss : defines how the module should access the shared plc
#                  resources. Possible values are "local" for direct access,
#                  and "isolate" for access through proxy process.
#                  This is the same as the command line --PLClocal and
#                  --PLCisolate arguments. The command line arguments take
#                  precedence over whatever is defined in the config file.
#                  If no value is specified by either method, the default
#                  DEF_PLC_LOCATION (currently = local) is used.
#
# privatemap_key = xxx: defines the key to use for the local map shared memory.
#                       Valid values go from 0..INT_MAX. A value of 0 has
#                       diferent meanings, depending on the location value.
#                       For local access, a value of 0 implies the use of malloc
#                       to allocate memry for the local map. For isolate access,
#                       a random key is used for the local map shared memory.
#                       The default value for every access method is 
#                       DEF_LOCALMAP_KEY (currently = 0)
#                       NOTE: in the source code the localmap is also sometimes
#                       refered to as the private map. This is something that 
#                       must be corrected...
