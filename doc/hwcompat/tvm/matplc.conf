#
# matplc.conf - configuration file
#

# the speed of the light-chasing (interval in miliseconds)
#
# Note that the test_il.il program has no knowledge
# of time. We can nevertheless control the scrolling speed
# by telling the PLC how often (i.e. the repetion period)
# the module should be run.
#
# The period value is given in milliseconds!
#
test_il: scan_period = 0.3


[PLC]
#synch the modules
synch test_il -> modbus_m
synch test_il -> vitrine
synch test_il -> test_il
synch_start test_il



# shared memory map section

[PLC]



# run the modules!!!
#
# Note: the Kbd module cannot run as a deamon, as it reads the
#       terminal's keyboard. It is therefore launched in the demo script.
#module Kbd ../basic/kbd
module test_il "./test_il"
module vitrine "../../mmi/curses/vitrine"
module plcshutdown "../../lib/util/plcshutdown"
module modbus_m "../../io/modbus/modbus_m_rtu" PLCdebug=3



#   P O I N T S
#   -----------
#
# These are also specified in the PLC section. However, it's not specified
# whether they are inputs or outputs here - that should be specified in the
# section(s) relating to the I/O modules. (That way, a point can be both an
# input and an output, or it can be output in several places. Also, some
# points are just internal coils and don't get input or output at all.)
#
# syntax:
# point name "full name" owner at offset.bit
#
# where:
# point     = 'point' identifier
# name      = Name used to refer to the point throughout the PLC
# full name = More extensive description of the point
#             This might be displayed by various diagnostic tools.
# owner     = Name of the module with write permission on the point
# at        = 'at' identifier
# offset    = location of word in the globalmap that holds the point's state
# bit       = the bit in the word (0-31), that holds the point's state

point L1	"light 1" test_il at  0.0
point L2	"light 2" test_il at  0.1
point L3	"light 3" test_il at  0.2
point L4	"light 4" test_il at  0.3
point L5	"light 5" test_il at	0.7
point L6	"light 6" test_il at	0.8
point L7	"light 7" test_il at	0.9
point L8	"light 8" test_il at	0.10
point           VL1_M   "mantissa"     modbus_m  16
point           VL1_E   "exponent"     modbus_m  16
#point left	"<- (key L)" Kbd at  1.4
#point right	"-> (key R)" Kbd at  1.5
point quit	"quit (key Q)" Kbd at 1.6

# Our test_il.il program needs three extra points
# in order to work.
point scroll_dir "scrolling direction" test_il at 2.0
point first_scan "first scan flag"     test_il at 2.1
point tmp_flag   "temporary flag"      test_il at 2.2
point K 	 "temp"		       test_il at 2.3
# read in the configuration of the display
# (this might equally well be simply specified here, but for the sake of
# demonstration it's in a separate file)
*include vitrine.conf

# note: the following section is only used by the keyboard module from the
# mmi/kbd directory; if you are not on the linux console, the kbd.c program
# from this directory is used instead, which doesn't use this
[Kbd]
# format:
#     key keycode point
# for now, keycode must be numeric
#key 38 left
#key 19 right
key 16 quit

# no debugging messages
quiet = 1


[plcshutdown]
# configure which point will be used to shutdown the plc
quit_pt = quit

# specify period for all the shutdown module, so it doesn't hog the CPU
plcshutdown: scan_period = 0.01


# Configure the modbus module, that will copy the
#  matplc points over the modbus network.

[modbus_m]
# Network configuration table
#
# network <network_name> <protocol> <parameters>
#
#  <network_name>   : the name of the network. Used later in the node address table.
#  <protocol>       : {rtu | ascii | tcp}
#
#      For rtu and ascii networks...
#  <parameters>     : [device <filename>]
#                     [baudrate <x>]
#                     [parity {even|odd|none}]
#                     [data_bits <x>]
#                     [stop_bits <x>]
#                     [ignore_echo {true|false}]
#                     [timeout <x>]
#                     [send_retries <x>]
#
#      For tcp networks...
#  <parameters>     : [host <x>]
#                     [port <x>]
#                     [timeout <x>]
#                     [send_retries <x>]
#                     [TCP_close {true | false}]
#  host <x>         : the IP address or DNS name of the server
#  port <x>         : x is either the port number on which the server is listening,
#                     or the service name, which will be mapped onto the port number
#                     according the configuration in the /etc/services file
#  TCP_close {true | false}
#                   : The openmodbus specification _sugests_ that all TCP connections
#                     should be closed if they are going to stay idle for longer than 1
#                     second. Setting this option to true will close all open TCP
#                     connections at the end of the scan. Note that connections will
#                     be re-established automatically for the next scan.
#                     Default is true, i.e. to close the connections at the end of the
#                     scan. This is due to the fact that some slaves may support a
#                     limited number of simultaneous TCP connections (i.e. limited number
#                     of simultaneous masters), and if we do not close the connections, we
#                     may be blocking those masters out of the slave!
#                     NOTE: true is the safest option, but with slightly longer delays.

# Sample network configurations...
network rtu_net         rtu   device /dev/ttyS0 baudrate 9600 parity none data_bits 8 stop_bits 1 ignore_echo false timeout 1.5 send_retries 2



# node address table
#
# node <slave_name> <network_name> <slave_addr>
#
#  <slave_name>   : the name of the slave node
#  <network_name> : the name of the network
#  <slave_addr>   : 0..255
#

# Sample slave configurations...
#node speed_drive    tcp_net 34
#node digital_IO     tcp_net 0
#node analog_IO      asc_net 23
node analog_IO       rtu_net 0x1b



#  I/O accessible over modbus network
#
# map [inv | invert] {in | out} <io_addr> <matplc point>
#
#  inv    -> invert the value being read from/writen to physical IO
#  invert -> invert the value being read from/writen to physical IO
#
#  in  -> copy from the input process image to the matplc point
#  out -> copy the state of the matplc point to the outout process image
#
#
#  <io_addr>  : modbus address
#               <slave>.<reg_type>.<reg_addr>
#
#  <slave>      : the name of the slave node, as it appears in the node address table.
#  <reg_type>   : in_bit | out_bit | in_word | out_word
#  <reg_addr>   : 0..9999



# Sample IO table
map in analog_IO.in_word.29 VL1_M
map in analog_IO.in_word.30 VL1_E


