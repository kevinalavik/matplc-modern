<html>
<head>
<title>MAT manual - interfacing</title>
</head>
<body>
<!--autolink--><a href="../../.."><img src="../../../images/MAT-linux-h100.gif" border=0 WIDTH="95" HEIGHT="100" alt="[MAT logo]" align="right"></a><a href="../../general/contribute/intro.html"><img src="../../../images/prev.gif" alt="[Prev]" width=32 height=32 border=0></a><a href="../../index.html"><img src="../../../images/up.gif" alt="[Up]" width=32 height=32 border=0></a><a href="../../appendix/glossary.html"><img src="../../../images/next.gif" alt="[Next]" width=32 height=32 border=0></a><!--/autolink-->
<h1>Interfacing other projects to the MatPLC</h1>

Interfacing the MatPLC and another project will of course always depend on
the details of the other project. However, typically, it would be done by
making the other project (or some part of it) a MatPLC module. In some
cases, an entirely new binary would be written, which is both a MatPLC
module and interacts with the other project in some way. In either case,
some part of the interface will be a MatPLC module.

<p>The minimum required for MatPLC integration is to link with the shared
(or static) library, and call five functions, with seven being preferable.
The functions are:

<dl>

<dt><code>plc_init(module_name,0,0)</code><dd>Initializes the library. The
module_name should be a string.

<dt><code>pt_handle = plc_pt_by_name(pt_name)</code><dd>Obtains a handle to
a MatPLC point, required for the <code>plc_get()</code> and
<code>plc_set()</code> functions. The pt_name should be a string, while
pt_handle should be of type <code>plc_pt_t</code>. This function, like
<code>plc_init()</code>, should be called before the time-critical part
begins.

<dt><code>plc_update()</code><dd>Updates the local (buffered) copy of all
the MatPLC points. It should be called before reading MatPLC points or
after writing them. If the module runs in a repeated "scan", this function
will usually be called once at the beginning of the scan, and once at the
end.

<dt><code>value = plc_get(pt_handle)</code><dd>Reads a MatPLC point (as it
was at the time of the last <code>plc_update()</code>, or as changed by
this module), returning it as an unsigned 32-bit integer. A 32-bit float
version of this function is also available.

<dt><code>plc_set(pt_handle, new_value)</code><dd>Writes an unsigned 32-bit
integer to a MatPLC point. A 32-bit float version of this function is also
available. The write will not be seen by the other MatPLC modules until
<code>plc_update()</code> is called.

</dl>

The two additional functions should be used if the module runs in a
repeated scan, like a traditional PLC. They enable the MatPLC to enforce
execution periods, sequencing of modules, RUN/STOP modes and the like. They
take no arguments.

<dl>

<dt>

<code>plc_scan_beg()</code><dd>Beginning of scan. This should precede the
<code>plc_update()</code> call.

<dt><code>plc_scan_end()</code><dd>End of scan. This should follow the
<code>plc_update()</code> call.

</dl>

<p>Naturally, you're welcome to use any other MatPLC functions that look
useful.

<p>These functions and their use are explained in more detail in the <a
href="../../custom/intro.html">Custom modules</a> chapter, especially in
the <a href="../../custom/native.html">Native C</a> section.

<h2>Usual usage</h2>

There are two usual ways of structuring modules: the first is the "classical
scan" familiar from stepladder, while the second is a "data interface",
where MatPLC and some other system exchange data.

<h3>Classical scan</h3>

Here, the behaviour resembles a stepladder scan: at the top of the loop,
data is read from the inputs (and other parts of the MatPLC), then the
logic is executed, and then data is written to the outputs (and other parts
of the MatPLC).

<p>This is the template for a classical-scan module:

<pre>
#include &lt;plc.h&gt;

int main(int argc,char *argv[])
{
  plc_init("<em>modulename</em>",argc,argv);

  <em>/* initialization goes here */</em>

  while (1) {
    plc_scan_beg();
    plc_update();

    <em>/* body of loop goes here */</em>

    plc_update();
    plc_scan_end();
  }
}
</pre>

<h3>Data interface</h3>

Here, the module does data interchange between MatPLC and
something else (the "other"). In the first half of the loop, any data
that's going from the other to the MatPLC is written into MatPLC points. In
the second half of the loop, data is taken from MatPLC points and sent to
the other. All the I/O modules work this way, exchanging data between
MatPLC and the I/O.

<p>One advantage is that the module doesn't need to keep track of which
points are read-only and which are read-write in the MatPLC; in the first
half, all points may be written, and in the second half all points may be
read. The <code>plc_update()</code> discards values for which the module
lacks write permission.

<p>This is the template for a data-interface module:

<pre>
#include &lt;plc.h&gt;

int main(int argc,char *argv[])
{
  plc_init("<em>modulename</em>",argc,argv);

  <em>/* initialization goes here */</em>

  while (1) {
    plc_scan_beg();

    <em>/* process data going to MatPLC */</em>

    plc_update();

    <em>/* process data coming from MatPLC */</em>

    plc_scan_end();
  }
}
</pre>

<h2>Notes</h2>

The MatPLC library is not particularly thread-safe. If you are using
multiple threads, it would be best to restrict MatPLC functions to one
thread. However, it is quite OK for one thread to be using the runtime
functions while another thread does a <code>plc_pt_by_name()</code>.

<p>
<!--autolink--><a href="../../general/contribute/intro.html"><img src="../../../images/prev.gif" alt="[Prev]" width=32 height=32 border=0></a><a href="../../index.html"><img src="../../../images/up.gif" alt="[Up]" width=32 height=32 border=0></a><a href="../../appendix/glossary.html"><img src="../../../images/next.gif" alt="[Next]" width=32 height=32 border=0></a><!--/autolink-->

<p><small>$Date: 2004/12/28 05:32:10 $</small>
</body>
</html>
