#
# matplc.conf - configuration file
#

# shared memory map section

[PLC]

# run the modules!!!
module dsp "../../logic/dsp/dsp"
module hmi_gtk2 "../../mmi/hmi_gtk2/hmi_gtk2"
module plcshutdown "../../lib/util/plcshutdown"



#   P O I N T S
#   -----------
point quit	"quit" 				hmi_gtk2
point alarm_gt	"alarm_gt"			dsp 
point alarm_lt	"alarm_lt"			dsp 
point alarm_0	"alarm_0"			dsp 

point in	"in" 				hmi_gtk2 32
point in_1	"in_1" 				dsp 32
point in_2	"in_2"	 			dsp 32
point out	"out" 				dsp 32
point out_1	"out_1 f32" 			dsp 32
point error_f32	"error_f32=in_f32-out_f32"	dsp 32
point out_2	"out_2 f32" 			dsp 32
point filter_out "filter_out f32"		dsp 32
point time	"time"				dsp 32

point_alias quit_app1 "quit" quit

hmi_gtk: scan_period = 0.01
quitcheck: scan_period = 0.01

# read in the configuration of the display
# *include vitrine.conf


#     S Y N C H R O N I S A T I O N    C O N F I G
#     --------------------------------------------
[PLC]
synch hmi_gtk2 -> dsp
synch dsp -> hmi_gtk2

synch_start hmi_gtk2 

# specify periods for the modules, so they don't hog the CPU
plcshutdown: scan_period = 0.01
# NOTE: dsp scan_period is specified further on...
 
 
[plcshutdown]
# configure which point will be used to shutdown the plc
quit_pt = quit



#     D S P    C O N F I G
#     --------------------

# The dsp config has two main parameter, and one table (fblock).
# The fblock table is used to configure the function blocks the dsp module
#  will execute.
# The two main parameters are:
#  period = xxx : the minimum period, in (microseconds) of the dsp func. block
#  out_time_pt = plc_pt : a plc_pt in which the dsp will store the current time


[dsp]
# scan_period = x 
#   time in seconds
scan_period = 0.1        
#scan_period = 0.01       

# plc point in which to store the time at which the dsp scan was executed
out_time_pt = time

[dsp]
# The fblock table is used to configure the function blocks the dsp module will
# execute. The function blocks are executed in the the same order they are 
# configured.
#
# Supported function block types:
#  typeconv : copy the value in an input point in one format, to an output
#             point in another format. Supported formats are i8 (8 bit int),
#             u8 (8 bit unsigned int), i16, u16, i32, u32, f32 (32 bit float).
#             All other function blocks use input and output points in the f32
#             format.
#  add      : Add (with a specified multiplier) a maximum of 10 PLC points.
#  ramp     : Limit the maximum speed (dx/dt) and aceleration (d2x/dt2) with 
#              which the value of a given variable (x) may change.
#  pid      : Implements an open loop PID function. For closed loop controllers,
#             use an add block to close the loop.
#  alarm    : Compares the value of a PLC point to up to a maximum of 10 limit
#             values, and sets the value of output points accordingly. 
#  nonlinear: Implements a deadband and limiting function.
#

#  THE ADD BLOCK
#  -------------
#fblock add out_pt     in_pt1 in_pt1_mult [in_pt2 in_pt2_mult] ...
#
#  out_pt = (in_pt1 * in_pt1_mult) + (in_pt2 * in_pt2_mult) + ...
#
#  Note: currently a maximum of 10 in_pt are supported.

#  THE MULT BLOCK
#  --------------
#fblock mult out_pt     in_pt1 in_pt1_ofs [in_pt2 in_pt2_ofs] ...
#
#  out_pt = (in_pt1 + in_pt1_ofs) * (in_pt2 + in_pt2_ofs) * ...
#
#  Note: currently a maximum of 10 in_pt are supported.

#  THE RAMP BLOCK
#  --------------
#fblock ramp in_pt out_pt [dxdt xx] [pos_dxdt xx] [neg_dxdt xx] [d2xdt2 xx] [pos_d2xdt2 xx] [neg_d2xdt2 xx]
#  Where:
#   in_pt      : the plc_pt where the input value (x) is stored
#   out_pt     : the plc_pt where to store the output value
#   dxdt       : maximum speed with which x may change (both positive and
#                 negative changes).
#   pos_dxdt   : maximum speed with which x may rise. Defaults to f32_MAX
#   neg_dxdt   : maximum speed with which x may fall. Defaults to f32_MAX
#   d2xdt2     : maximum speed with which dx/dt may change (both positive and
#                 negative changes).
#   pos_d2xdt2 : maximum speed with which dx/dt may rise. Defaults to f32_MAX
#   neg_d2xdt2 : maximum speed with which dx/dt may fall. Defaults to f32_MAX

#  THE ALARM BLOCK
#  ---------------
#fblock alarm in_pt {true_val|abs_val} out_pt1 comp1 limit1 [out_pt2 comp2 limit2] ...
# where:
#   in_pt   : matplc point to be used as input for the alarm block
#   true_val: use the value in in_pt without any changes
#   abs_val : use the absolute value in in_pt for determining the alarms
#   out_pt  : matplc point to be used as output for the alarm block
#   limitl  : f32 value used for the alarm comparison
#   comp    : specifies when the alarm should be set.
#             one of:
#               {less | lt | smaller | st |
#                less_or_equal | le | smaller_or_equal | se |
#                greater | gt | greater_or_equal | ge |
#                equal | eq | not_equal | ne}
#              Note: less, lt, smaller, and st, are all equivalent
#                     greater and gt are equivalent
#                     greater_or_equal and ge are equivalent
#                     etc...
#
# Example:
# fblock alarm in_pt true_val out_1 10 lt out_2 10 gt out_3 20.55 eq
#  (consider in_pt_val the value currently stored in the in_pt PLC point)
#   then the above config line will have the efect of:
#    - out_1 being true (1) when in_pt_val < 10, and (false) 0 otherwise
#    - out_2 being true (1) when in_pt_val > 10, and (false) 0 otherwise
#    - out_1 being true (1) when in_pt_val = 20.55, and (false) 0 otherwise
#
 
#  THE PID BLOCK
#  -------------
#fblock pid in_pt      out_pt    [P [I [D]]]

#  THE TYPECONV BLOCK
#  ------------------
#fblock typeconv in_pt in_pt_type out_pt out_pt_type ...

#  THE NONLINEAR BLOCK
#  -------------------
#fblock nonlinear in_pt out_pt [cutoff_top xx] [cutoff_bot xx] [deadband_top xx] [deadband_bot xx] [deadband_out xx] [gain xx]
# defaults are:
#   cutoff_top  : f32_MAX
#   cutoff_bot  : -f32_MAX
#   deadband_top: 0
#   deadband_bot: 0
#   deadband_out: 0
#   gain        : 1
#
#
#  This function block implements a nonlinear block supporting both
#  a deadband function centered around a configured offset, and a limiter.
#  In addition, it also allows for a linear gain and offset top be applied
#  the output of it's nonlinear function. These last two are essentially to
#  reduce the number of function blocks eventually required to implement
#  a specific global user function.
#
#
#
#  The nonlinear part, implements the following function:
#
#
#     out = nl_f(in):
#			   out
#			    ^
#			    |
#			    |
#		     co_top |.............................--------
#			    |                            /
#			    |                           /
#			    |                          /
#			    |                         /
#			    |                        /
#			    |                       /
#			    |                      /
#			    |                     / inclination = 1
#			    |                    /
#			    |                   /
#		     db_out |...----------------
#			    |  /.              .
#			    | / .              .
#			    |/  .              .
#			    |   .              .
#		   	   /|   .              .
#		          / |   .              .
#		         /  |   .              .
#		        /   |   .              .
#  <--------------------------------------------------------------> in
#		      /     | db_bot         db_top
#		     /      |
#		    /       |
#		   /        |
#  ----------------.........| co_bot
#			    |
#			    |
#			    |
#			    v
#
#	(co = cutoff      db = deadband)
#
#
#  The linear part implements the following function:
#   out = l_f(in) = in * gain
#
#
#  The output of the complete nonlinear block is:
#   out =  nl_f( in * gain )
#
 
#fblock typeconv in_pt in_pt_type out_pt out_pt_type ...
fblock  typeconv in    i32        in_1   f32         out_1 f32 out i32

#fblock ramp in_pt out_pt [dxdt xx] [pos_dxdt xx] [neg_dxdt xx] [d2xdt2 xx] [pos_d2xdt2 xx] [neg_d2xdt2 xx]
fblock ramp in_1 in_2 d2xdt2 1

#fblock add out_pt     in_pt1 in_pt1_mult [in_pt2 in_pt2_mult] ...
fblock  add error_f32  in_2   1           out_1   -1

#fblock pid in_pt      out_pt    [P [I [D]]]
fblock  pid error_f32  out_1      0.0  1  0.000

#fblock nonlinear in_pt out_pt [cutoff_top xx] [cutoff_bot xx] [deadband_top xx] [deadband_bot xx] [deadband_out xx] [gain xx]
fblock nonlinear out_1 out_2 cutoff_top 7 cutoff_bot 2 deadband_bot 4 deadband_top 5 deadband_out 4 gain 1

#fblock alarm in_pt {true_val|abs_val} out_pt1 comp1 limit1 [out_pt2 comp2 limit2] ...
fblock  alarm error_f32 abs_val alarm_gt gt 1  alarm_lt lt 1  alarm_0 eq 0



#fblock filter in_1 filter_out iir 1 -2 1 0.2740203 0.7324040     -2 1 0.2184302 .03809528  -2 1 0.1862832 0.1777139  -2 1 0.1682884 0.0639486  -2 1 0.1601550 0.0125277
# CHECKED
#fblock filter in_1 filter_out butterworth lowpass 1 .1737 40 500 750
fblock filter in_1 filter_out butterworth highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out chebyshev   lowpass 1 .1737 40 500 750
#fblock filter in_1 filter_out chebyshev   highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out elliptic   lowpass 1 .1737 40 500 750
#fblock filter in_1 filter_out elliptic   highpass 1 .1737 40 500 750

# UNCHECKED
#fblock filter in_1 filter_out elliptic   highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out butterworth bandpass 1 .5 35 250 500 750 1000
#fblock filter in_1 filter_out butterworth bandpass 1 3 40 250 500 750 1000
#fblock filter in_1 filter_out butterworth lowpass 1 3 30 500 750
