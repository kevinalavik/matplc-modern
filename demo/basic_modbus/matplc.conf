[PLC]
#
# matplc.conf - configuration file
#

# the speed of the light-chasing (interval in seconds)
Chaser: delay = 0.3


[PLC]
point 		L	"light"        Chaser 4
point_alias 	L1	"light 1"      L 0
point_alias 	L2	"light 2"      L 1
point_alias 	L3	"light 3"      L 2
point_alias 	L4	"light 4"      L 3
point       	left	"<- (key L)"   Kbd
point    	right	"-> (key R)"   Kbd
point 		quit	"quit (key Q)" Kbd


# run the modules!!!
#
# Note: the Kbd module cannot run as a deamon, as it reads the
#       terminal's keyboard. It is therefore launched in the demo script.
#module Kbd ../basic/kbd
module Chaser "../basic/chaser"
module vitrine "../../mmi/curses/vitrine"
module plcshutdown "../../lib/util/plcshutdown"
# Uncomment the modbus protocol version you wish to run...
#module modbus_m "../../io/modbus/modbus_m_rtu"
#module modbus_m "../../io/modbus/modbus_m_asc"
module modbus_m "../../io/modbus/modbus_m_tcp"


*include vitrine.conf

[PLC]
# synch the modules

synch Chaser -> modbus_m
synch Chaser -> vitrine
synch Chaser -> Chaser

synch_start Chaser

Chaser: scan_period = 0.01


[plcshutdown]
# configure which point will be used to shutdown the plc
quit_pt = quit
scan_period = 0.01




# Configure the modbus module, that will copy the
#  matplc points over the modbus network.

[modbus_m]
# Network configuration table
#
# network <network_name> <protocol> <parameters>
#
#  <network_name>   : the name of the network. Used later in the node address table.
#  <protocol>       : {rtu | ascii | tcp}
#
#      For rtu and ascii networks...
#  <parameters>     : [device <filename>]
#                     [baudrate <x>]
#                     [parity {even|odd|none}]
#                     [data_bits <x>]
#                     [stop_bits <x>]
#                     [ignore_echo {true|false}]
#                     [timeout <x>]
#                     [send_retries <x>]
#
#      For tcp networks...
#  <parameters>     : [host <x>]
#                     [port <x>]
#                     [timeout <x>]
#                     [send_retries <x>]
#                     [TCP_close {true | false}]
#  host <x>         : the IP address or DNS name of the server
#  port <x>         : x is either the port number on which the server is listening,
#                     or the service name, which will be mapped onto the port number
#                     according the configuration in the /etc/services file
#  TCP_close {true | false}
#                   : The openmodbus specification _sugests_ that all TCP connections
#                     should be closed if they are going to stay idle for longer than 1
#                     second. Setting this option to true will close all open TCP
#                     connections at the end of the scan. Note that connections will
#                     be re-established automatically for the next scan.
#                     Default is true, i.e. to close the connections at the end of the
#                     scan. This is due to the fact that some slaves may support a
#                     limited number of simultaneous TCP connections (i.e. limited number
#                     of simultaneous masters), and if we do not close the connections, we
#                     may be blocking those masters out of the slave!
#                     NOTE: true is the safest option, but with slightly longer delays.

# Sample network configurations...
network rtu_net         rtu   device /dev/ttyS1 baudrate 9600 parity none data_bits 8 stop_bits 1 ignore_echo false timeout 1.5 send_retries 2
network asc_net         ascii device /dev/ttyS1 baudrate 9600 parity none data_bits 8 stop_bits 1 ignore_echo false timeout 1.5 send_retries 2
network tcp_net         tcp   host   localhost  port 5502  timeout .1 send_retries 1 TCP_close true



# node address table
#
# node <slave_name> <network_name> <slave_addr>
#
#  <slave_name>   : the name of the slave node
#  <network_name> : the name of the network
#  <slave_addr>   : 0..255
#

# Sample slave configurations...
node speed_drive    tcp_net 34
node digital_IO     tcp_net 0
node analog_IO      asc_net 23



#  I/O accessible over modbus network
#
# map [inv | invert] {in | out} <io_addr> <matplc point>
#
#  inv    -> invert the value being read from/writen to physical IO
#  invert -> invert the value being read from/writen to physical IO
#
#  in  -> copy from the input process image to the matplc point
#  out -> copy the state of the matplc point to the outout process image
#
#
#  <io_addr>  : modbus address
#               <slave>.<reg_type>.<reg_addr>
#
#  <slave>      : the name of the slave node, as it appears in the node address table.
#  <reg_type>   : in_bit | out_bit | in_word | out_word
#  <reg_addr>   : 0..9999



# Sample IO table
map out digital_IO.out_bit.1 L1
map out digital_IO.out_bit.2 L2
map out digital_IO.out_bit.3 L3
map out digital_IO.out_bit.4 L4

