#
# matplc.conf - configuration file
#

# shared memory map section

[PLC]


# run the modules!!!
#
# Note: the Kbd module cannot run as a deamon, as it reads the
#       terminal's keyboard. It is therefore launched in the demo script.
#module Kbd ./kbd
module dsp "../../logic/dsp/dsp"
module vitrine "../../mmi/curses/vitrine"
module plcshutdown "../../lib/util/plcshutdown"



#   P O I N T S
#   -----------
point quit	"quit" 				Kbd
point alarm_gt	"alarm_gt"			dsp
point alarm_lt	"alarm_lt"			dsp
point alarm_0	"alarm_0"			dsp

point in	"in" 				Kbd 32
point in_1	"in_1" 				dsp 32
point in_2	"in_2"	 			dsp 32
point out	"out" 				dsp 32
point out_1	"out_1 f32" 			dsp 32
point error_f32	"error_f32=in_f32-out_f32"	dsp 32
point out_2	"out_2 f32" 			dsp 32
point filter_out "filter_out f32"		dsp 32
point time	"time"				dsp 32

# read in the configuration of the display
*include vitrine.conf


#     S Y N C H R O N I S A T I O N    C O N F I G
#     --------------------------------------------
[PLC]
synch vitrine -> dsp
synch dsp -> vitrine

synch_start dsp

# specify periods for the modules, so they don't hog the CPU
dsp: scan_period = 0.05
plcshutdown: scan_period = 0.01


[plcshutdown]
# configure which point will be used to shutdown the plc
quit_pt = quit


#     D S P    C O N F I G
#     --------------------
[dsp]

# The dsp config has one main parameter, and one table (fblock).
# The fblock table is used to configure the function blocks the dsp module
#  will execute.
# The main parameter is:
#  out_time_pt = <plc_pt>
# where plc_pt is where the dsp will store the current time
out_time_pt = time


# NOTE: The scan_period parameter is valid for any module, but it will
#       probably be used extensively by the dsp module.
# scan_period = x
#   time in seconds
#
# NOTE: already specified above...
#scan_period = 0.1
#scan_period = 0.01


# The fblock table is used to configure the function blocks the dsp module will
# execute. The function blocks are executed in the the same order by which
# they are configured.
#
# Supported function block types:
#  typeconv   : copy the value in an input point in one format, to an output
#               point in another format. Supported formats are i32 (32 bit int),
#               u32 (32 bit unsigned int), and f32 (32 bit float).
#               All other function blocks use input and output points in the f32
#               format.
#  add        : Add (with a specified multiplier) a maximum of 10 PLC points.
#  mult       : Multiply a maximum of 10 PLC points.
#  pow        : Raise a plc point to the power of x (x being a parameter).
#  pid        : Implements an open loop PID function. For closed loop controllers,
#               use an add block to close the loop.
#  filter     : Filter the input, using an iir (infinite impulse response)
#               filter.
#  ramp       : Limit the maximum speed (dx/dt) and aceleration (d2x/dt2) with
#               which the value of a given variable (x) may change.
#  nonlinear  : Implements a deadband and limiting function.
#  alarm      : Compares the value of a PLC point to up to a maximum of 10 limit
#               values, and sets the value of output points accordingly.
#  multiplexor: Copy one of the input points to the output point. The input
#               point that is copied is dependant on the value of a
#               control point.
#

#  THE TYPECONV BLOCK
#  ------------------
#fblock typeconv <in_pt1> <in_pt1_type> <out_pt1> <out_pt1_type>
#                [<in_pt2> <in_pt2_type> <out_pt2> <out_pt2_type>] ...
#
# <in_pt_type>
# <out_pt_type> : How to interpret the bits in the previous point.
#                 = {i32 | u32 | f32}

#  THE ADD BLOCK
#  -------------
#fblock add <out_pt>     <in_pt1> <in_pt1_mult> [<in_pt2> <in_pt2_mult>] ...
#
#  out_pt = (in_pt1 * in_pt1_mult) + (in_pt2 * in_pt2_mult) + ...
#
#  Note: currently a maximum of 10 in_pt are supported.

#  THE MULT BLOCK
#  --------------
#fblock mult <out_pt>     <in_pt1> <in_pt1_ofs> [<in_pt2> <in_pt2_ofs>] ...
#
#  out_pt = (in_pt1 + in_pt1_ofs) * (in_pt2 + in_pt2_ofs) * ...
#
#  Note: currently a maximum of 10 in_pt are supported.

#  THE POW BLOCK
#  --------------
#fblock pow <out_pt> <in_pt> <in_pt_pow>
#
# where:
#   out_pt    : matplc point to be used as output
#   in_pt     : matplc point to be used as input
#   in_pt_pow : raise in_pt to in_pt_pow (f32 value)
#
#                   in_pt_pow
#   out_pt = (in_pt)

#  THE PID BLOCK
#  -------------
#fblock pid <in_pt>      <out_pt>    [<P> [<I> [<D>]]] max_out <upper_lim> min_out <lower_lim>
#
# This block implements a parallel PID controler.
# out_pt = P*in_pt + I*integral(in_pt, dt) + D*din_pt/dt
#
# Note that the integral(in_pt, dt) is automatically adjusted to guarantee that:
#  upper_lim <= out_pt <= lower_lim
#
# default values:
#       P = 1
#       I = 0
#       D = 0
#

#  THE FILTER BLOCK
#  ----------------
#fblock filter iir [<C> [<A1> [<A2> [<B1> [<B2>]]]] ...
#  or
#fblock filter <filter_type> <filter_shape> <gain> <passband_tol> <stopband_tol> <f1> <f2> [<f3> <f4>]
#
# where:
#   C, A1, A2, B1, B2 : second order iir filter section parameters
#                       Please see further ahead for an explanation of what
#                       is an iir filter.
#
#  filter_type:
#    {butterworth | chebyshev | elliptic}
#    This method is used to configure the filter as an equivalent to an
#    analog filter. At setup these parameters are transformed into the
#    equivalent iir filter, which will be executed at run-time.
#
#  filter_shape:
#    {lowpass | highpass | bandpass | bandstop}
#    NOTE: These transformations have not been completely debuged.
#          lowpass and highpass *should* be working correctly.
#          bandpass and bandstop are known to be buggy.
#
#  gain:
#   the gain of the filter for the passband frequencies
#    (F is sampling frequency).
#   For low_pass,  gain = g(0),   i.e. gain at f = 0 Hz
#   For high_pass, gain = g(F/2), i.e. gain at f = F/2 Hz
#   For band_pass, gain = g(fp1/2 + fp2/2), gain at f = (fp1 + fp2) / 2 Hz
#   For band_stop, gain = sqrt [ g(0)*g(0) + g(F/2)*g(F/2) ]
#
#  passband_tol (stopband_tol):
#    maximum(minimum) atenuation, in positive dB, for the
#    passband(stopband) frequencies
#
#  fX:
#    frequency limits in Hz
#    NOTE: The meaning of f1, f2, f3 and f4 depends on the filter shape.
#          The idea is to have valid frequencies always in increasing value.
#          for a LowPass:
#                    f1 - passband frequency limit
#                    f2 - stopband frequency limit
#          for a HighPass:
#                    f1 - stopband frequency limit
#                    f2 - passband frequency limit
#          for a BandPass:
#                    f1 - lower  stopband frequency limit
#                    f2 - lower  passband frequency limit
#                    f3 - higher passband frequency limit
#                    f4 - higher stopband frequency limit
#          for a BandStop:
#                    f1 - lower  passband frequency limit
#                    f2 - lower  stopband frequency limit
#                    f3 - higher stopband frequency limit
#                    f4 - higher passband frequency limit
#
#
#
# The filter block implements X second order iir filters in series.
# A second order iir filter:
#
#
#          |\
#          | \
#  in >----|C >-->(+)-->(+)----------------------->(+)-->(+)---> out
#          | /     ^     ^               |          ^     ^
#          |/      |     |               |          |     |
#                  |     |               v          |     |
#                  |     |             (z-1)        |     |
#                  |     |   /|    /|    |    |\    |     |
#                  |     |  / |   / |    |    | \   |     |
#                  |     --<-1|--<B1|<---|--->|A1>---     |
#                  |        \ |   \ |    |    | /         |
#                  |         \|    \|    v    |/          |
#                  |                   (z-1)              |
#                  |         /|    /|    |    |\          |
#                  |        / |   / |    |    | \         |
#                  |-------<-1|--<B2|<---|--->|A2>--------|
#                           \ |   \ |         | /
#                            \|    \|         |/
#
#
#        where (z-1) is a delay block, i.e., in the z transform,
#         z to the power of -1.
#

#  THE RAMP BLOCK
#  --------------
#fblock ramp <in_pt> <out_pt> [dxdt <xx>] [pos_dxdt <xx>] [neg_dxdt <xx>] [d2xdt2 <xx>] [pos_d2xdt2 <xx>] [neg_d2xdt2 <xx>]
#  Where:
#   in_pt      : the plc_pt where the input value (x) is stored
#   out_pt     : the plc_pt where to store the output value
#   dxdt       : maximum speed with which x may change (both positive and
#                 negative changes).
#   pos_dxdt   : maximum speed with which x may rise. Defaults to f32_MAX
#   neg_dxdt   : maximum speed with which x may fall. Defaults to f32_MAX
#   d2xdt2     : maximum speed with which dx/dt may change (both positive and
#                 negative changes).
#   pos_d2xdt2 : maximum speed with which dx/dt may rise. Defaults to f32_MAX
#   neg_d2xdt2 : maximum speed with which dx/dt may fall. Defaults to f32_MAX

#  THE NONLINEAR BLOCK
#  -------------------
#fblock nonlinear <in_pt> <out_pt> [cutoff_top <xx>] [cutoff_bot <xx>] [deadband_top <xx>] [deadband_bot <xx>] [deadband_out <xx>] [gain <xx>]
# defaults are:
#   cutoff_top  : f32_MAX
#   cutoff_bot  : -f32_MAX
#   deadband_top: 0
#   deadband_bot: 0
#   deadband_out: 0
#   gain        : 1
#
#
#  This function block implements a nonlinear block supporting both
#  a deadband function centered around a configured offset, and a limiter.
#  In addition, it also allows for a linear gain and offset to be applied to
#  the output of it's nonlinear function. These last two are essentially to
#  reduce the number of function blocks eventually required to implement
#  a specific global user function.
#
#
#
#  The nonlinear part, implements the following function:
#
#
#     out = nl_f(in):
#			   out
#			    ^
#			    |
#			    |
#		     co_top |.............................--------
#			    |                            /
#			    |                           /
#			    |                          /
#			    |                         /
#			    |                        /
#			    |                       /
#			    |                      /
#			    |                     / inclination = 1
#			    |                    /
#			    |                   /
#		     db_out |...----------------
#			    |  /.              .
#			    | / .              .
#			    |/  .              .
#			    |   .              .
#		   	   /|   .              .
#		          / |   .              .
#		         /  |   .              .
#		        /   |   .              .
#  <--------------------------------------------------------------> in
#		      /     | db_bot         db_top
#		     /      |
#		    /       |
#		   /        |
#  ----------------.........| co_bot
#			    |
#			    |
#			    |
#			    v
#
#	(co = cutoff      db = deadband)
#
#
#  The linear part implements the following function:
#   out = l_f(in) = in * gain
#
#
#  The output of the complete nonlinear block is:
#   out =  nl_f( in * gain )
#

#  THE ALARM BLOCK
#  ---------------
#fblock alarm <in_pt> {true_val|abs_val} <out_pt1> <comp1> <limit1> [<out_pt2> <comp2> <limit2>] ...
# where:
#   in_pt   : matplc point to be used as input for the alarm block
#   true_val: use the value in in_pt without any changes
#   abs_val : use the absolute value in in_pt for determining the alarms
#   out_pt  : matplc point to be used as output for the alarm block
#   limitl  : f32 value used for the alarm comparison
#   comp    : specifies when the alarm should be set.
#             one of:
#               {less | lt | smaller | st |
#                less_or_equal | le | smaller_or_equal | se |
#                greater | gt | greater_or_equal | ge |
#                equal | eq | not_equal | ne}
#              Note: less, lt, smaller, and st, are all equivalent
#                     greater and gt are equivalent
#                     greater_or_equal and ge are equivalent
#                     etc...
#
# Example:
# fblock alarm in_pt true_val out_1 10 lt out_2 10 gt out_3 20.55 eq
#  (consider in_pt_val the value currently stored in the in_pt PLC point)
#   then the above config line will have the efect of:
#    - out_1 being true (1) when in_pt_val < 10, and (false) 0 otherwise
#    - out_2 being true (1) when in_pt_val > 10, and (false) 0 otherwise
#    - out_1 being true (1) when in_pt_val = 20.55, and (false) 0 otherwise
#

#  THE MULTIPLEXOR BLOCK
#  ---------------------
#fblock multiplexor <out_pt> <ctrl_pt> <in_pt1> [<limit1> <in_pt2>] ...
#
# where:
#   out_pt : matplc point to be used as output for the multiplexor block
#   ctrl_pt: matplc point used to decide which input to copy to the output
#   in_ptX : matplc point to be used as input for the multiplexor block
#   limitX : limit value at which the output switches from one input to another
#
#   out_pt = in_pt1 -> if (ctrl_pt <  limit1)
#   out_pt = in_pt2 -> if (ctrl_pt >= limit1) AND (ctrl_pt < limit2)
#   out_pt = in_pt3 -> if (ctrl_pt >= limit2) AND (ctrl_pt < limit3)
#   ...







#fblock typeconv in_pt in_pt_type out_pt out_pt_type ...
fblock  typeconv in    i32        in_1   f32         out_1 f32 out i32

#fblock ramp in_pt out_pt [dxdt xx] [pos_dxdt xx] [neg_dxdt xx] [d2xdt2 xx] [pos_d2xdt2 xx] [neg_d2xdt2 xx]
fblock ramp in_1 in_2 d2xdt2 1

#fblock add out_pt     in_pt1 in_pt1_mult [in_pt2 in_pt2_mult] ...
fblock  add error_f32  in_2   1           out_1   -1

#fblock pid in_pt      out_pt    [P [I [D]]]
fblock  pid error_f32  out_1      0.0  1  0.000

#fblock nonlinear in_pt out_pt [cutoff_top xx] [cutoff_bot xx] [deadband_top xx] [deadband_bot xx] [deadband_out xx] [gain xx]
fblock nonlinear out_1 out_2 cutoff_top 7 cutoff_bot 2 deadband_bot 4 deadband_top 5 deadband_out 4 gain 1

#fblock alarm in_pt {true_val|abs_val} out_pt1 comp1 limit1 [out_pt2 comp2 limit2] ...
fblock  alarm error_f32 abs_val alarm_gt gt 1  alarm_lt lt 1  alarm_0 eq 0



#fblock filter in_1 filter_out iir 1 -2 1 0.2740203 0.7324040     -2 1 0.2184302 .03809528  -2 1 0.1862832 0.1777139  -2 1 0.1682884 0.0639486  -2 1 0.1601550 0.0125277
# CHECKED
#fblock filter in_1 filter_out butterworth lowpass 1 .1737 40 500 750
fblock filter in_1 filter_out butterworth highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out chebyshev   lowpass 1 .1737 40 500 750
#fblock filter in_1 filter_out chebyshev   highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out elliptic   lowpass 1 .1737 40 500 750
#fblock filter in_1 filter_out elliptic   highpass 1 .1737 40 500 750

# UNCHECKED
#fblock filter in_1 filter_out elliptic   highpass 1 .1737 40 500 750
#fblock filter in_1 filter_out butterworth bandpass 1 .5 35 250 500 750 1000
#fblock filter in_1 filter_out butterworth bandpass 1 3 40 250 500 750 1000
#fblock filter in_1 filter_out butterworth lowpass 1 3 30 500 750

