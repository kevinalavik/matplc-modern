#
# matplc.conf - configuration file
#

# the speed of the light-chasing (interval in seconds)
Chaser: delay = 0.3


[PLC]

# run the modules!!!
#
# Note: the Kbd module cannot run as a deamon, as it reads the
#       terminal's keyboard. It is therefore launched in the demo script.
#module Kbd ../basic/kbd
module Chaser "../basic/chaser"
module vitrine "../../mmi/curses/vitrine"
module parport "../../io/parport/parport";
module plcshutdown "../../lib/util/plcshutdown"



point L1	"light 1" Chaser
point L2	"light 2" Chaser
point L3	"light 3" Chaser
point L4	"light 4" Chaser
point left	"<- (key L)" Kbd
point right	"-> (key R)" Kbd
point quit	"quit (key Q)" Kbd

*include vitrine.conf

[PLC]
# synch the modules

synch Chaser -> parport
synch Chaser -> vitrine
synch vitrine -> Chaser

synch_start Chaser

# specify periods for all the modules, so they don't hog the CPU
Chaser: scan_period = 0.01
plcshutdown: scan_period = 0.01
 
#neither of the keyboard modules (Kbd or kbd) can be sensibly given periods
 
 
[plcshutdown]
# configure which point will be used to shutdown the plc
quit_pt = quit


# Configure the parport module, that will copy the
#  matplc points to the parallel port.
[parport]

# The parallel ports base address.
io_addr = 0x378   # 0x378 is the default if no io_addr is specified.
                  # You may also like to try 0x278 if the first doesn't work

# If you prefer to go though the kernel driver, then specify the device file
dev_file = /dev/plc_parport0

# NOTE: If both of the above methods of accessing the parallel port are
#       configured, then the kernel driver will be used. Only if this method
#       fails will it fall back to the direct access mode, using the specified
#       (or default) io base address.

#  Digital I/O available on the parallel port
#
#  Bitmap:
#  Data In/Out     D0-D7   8 LS TTL outputs/inputs (pins 2-9 respectively)
#  Status In       S3-S7   5 LS TTL inputs (pins 15/13/12/10/11 respectively)
#  Control In/Out  C0-C3   4 TTL Open Collector outputs/inputs (pins 1/14/16/17)
#
#  NOTE: Some of the S and C bits are inverted by the parallel port hardware.
#        We re-invert all these bits so that this library presents a coherent
#        positive logic interface.
#
#  NOTE: C0-C3 are usually used solely as outputs, but since they are
#        open collector, they can be put into high impedance state by writing
#        1 to every output. In this state, these lines may be used as inputs!
#        That is why we inhibit any writes to this register while it is
#        in input mode.
#	 Note that not all PC hardware allows reading the true input value
#	 of this register when the outputs are set to high impedance, so this
#        may not always work.
#        Note that this may also not work if the access to the parallel port
#        is made through the kernel, instead of going direct by reading io ports
#        It is guaranteed not to work on a PC style hardware and if using kernel
#        access because the kernel pc parallel port driver does not support
#        reading the true inputs of this register. It merely hands out a copy
#        of the most recent write.
#


# define the direction {in | out} the D register should use
Ddir = out

# define the direction {in | out} the C register should use
Cdir = in

# The S register can only be used as input!

# NOTE: If the direction of a register is not explicitly specified, it
#       will be inferred from the direction of the first point mapping
#       in which it appears.


# node format
# map [inv | invert] {in | out} <io_addr> <matplc point>
#
#  inv    -> invert the value being read from/writen to physical IO
#  invert -> invert the value being read from/writen to physical IO
#
#  in  -> copy the state of the parallel port register to the matplc point
#  out -> copy the state of the matplc point to the parallel port register
#
#  <io_addr>  : address of physical IO. For the parallel port, use the syntax
#               <register>.<bit>
#  <register> : one of C, D or S
#  <bit>      : [0..7] for D
#               [0..3] for C
#               [0..4] for S
#
# NOTE: all bits of the same register must use the same direction (in or out)



# Note: I am using leds that light up when the output is low, so I choose
#       to invert the matplc points before copying to the parallel port.
#       That way, the led will light up when the matplc point is set (=1)

map inv out D.0 L1
map inv out D.1 L2
map inv out D.2 L3
map inv out D.3 L4
map inv out D.4 L1
map inv out D.5 L2
map inv out D.6 L3
map inv out D.7 L4

