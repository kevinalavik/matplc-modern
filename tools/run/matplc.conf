#
# sample matplc.conf configuration file
#


#   G E N E R A L   S Y N T A X
#   ===========================
#
# (name,value) pairs:
# name = value
#
# tables:
# table_name value_1_1 value_1_2 value_1_3 ...
# table_name value_2_1 value_2_2 value_2_3 ...
# ...
#
#
# tables and names are divided into sections.
# (Jiri, do you think you can come up with some good sentences
#  explainig how sections work, and how modules look for parameters
#  in sections named after their module_name ??)
# Should also explain how *includes are supported, and that it is protected
# against circular includes.
#
#
# NOTES:
#  (1)  when value is an integer, it may usually be written in
#       hexadecimal (0xF45A), octal (0172132) or decimal (62554) formats.  
#
#  (2)  when value or a name is a string with white space characters, it 
#       must be enclosed within "  ("this is a single value")



[PLC]
module pid1 ../../logic/dsp/dsp

# syntax for places
#
# place <place_name> [<init_numb_tokens>] 
#
# Note: the initial number of tokens defaults to 0.
#
place place1
place place2 1
place place3
place place4
place place5 200

# syntax for tansitions
#
# transition <transition_name>
#
transition T0
transition T1
transition T2

transition Tstart
transition Tstop



# arc syntax:
#            
#  arc {<transition> | <place>} arrow {<transition> | <place>}
#
#       Note: two places or two transitions is an error. 
#
#  where arrow is:  [-][(][<weight>][)][-]>
#                   default weight is 1
#                   Note that the only required character for the arrow is '>'
#
# examples of possible valid syntax for the arrows in the arc definitions...
#arc place1  -0->    T1
#arc T1      -(1)->  place2 
#arc place2  -2>     T2
#arc T2      3)->    place3 
#arc place3  -0x01-> T3
#arc T3      -9999-> place1 
#arc T2      >       place1 
#arc T1      --()--> place1 


arc place1  -> Tstop
arc Tstart  -> place1

arc place1  -> T1
arc T1      -> place1 
arc T1      -> place2 
arc place2  -> T2


# synchronisation points (synchpt) syntax:
#
# synchpt <synchpt_name> <synchpt_type> [<type_parameters>]
#
# where cyrrent suported types and their required parameters are:
#     transition     <transition_name>
#     transition.beg <transition_name>
#     transition.end <transition_name>
#
#
# NOTE: the synchpt name "NULL" is reserved for the null synchpt.
#       wherever a name = value pair requires the name of a synchpt for the
#       value, the name "NULL" may be used to specify the null synchpt.
#
#
#define some synchpts so we can later play around with ./plctest -w <synchpt>
synchpt  s0.beg transition.beg T0 
synchpt  s0.end transition.end T0 
synchpt  s0     transition     T0 
synchpt  s1.beg transition.beg T1 
synchpt  s1.end transition.end T1 
synchpt  s1     transition     T1 
synchpt  s2     transition     T2 
synchpt  start  transition     Tstart 
synchpt  stop   transition     Tstop 



[test]        # this is the default module name of plctest

# define the synchpts to use by plc_loop_beg() and plc_loop_end()
loopbeg = s1.beg
loopend = s1.end

[test2]
# define the synchpts to use by plc_loop_beg() and plc_loop_end()
loopbeg = s2




[PLC]
#
#   T h e   P L C   s e c t i o n
#   =============================
#
#
# The PLC section is used to configure parameters related to the PLC, and
# are used by all modules. Some other parameters related to the PLC, but
# module specific, must be specified under those modules' sections.
#
# name = value pairs:
# ------------------
# confmap_key   = xxx : The key to use for the confmap shared memory. This is 
#                       actually the same parameter configured through 
#                       --PLCplc_id=xxx. The command line argument takes 
#                       precedence over the value configured in this file.
#                       If this parameter is not specified either way, the
#                       default value DEF_CONFMAP_KEY (currenty = 23) is used.
#                       Valid values go from 0..INT_MAX. If 0 is specified,
#                       then a random key is chosen.
#
# globalmap_key = xxx : The key to use for the globalmap shared memory segment.
#                       If no value is specified, then the default 
#                       DEF_GLOBALMAP_KEY is used (currently = 0). Valid values
#                       go from 0..INT_MAX. If 0 is specified, then a random
#                       key is chosen.
#
# sem_key       = xxx : The key to use for the globalmap semaphore set used by.
#                       the CMM. If no value is specified, then the default 
#                       DEF_SEM_KEY is used (currently = 0). Valid values
#                       go from 0..INT_MAX. If 0 is specified, then a random
#                       key is chosen.
#
# confmap_pg    = xxx : The size of the confmap given in number of memory pages.
#                       If this value is left unspecified, the default value 
#                       DEF_CONFMAP_PG (currently = 2) is used.
#                       The size of each memory page is given by PAGE_SIZE
#                       defined in asm/page.h or sys/user.h (which is the
#                       correct include?) (for linux on intel (?) PAGE_SIZE
#                       is 4 kBytes).
#
# globalmap_pg  = xxx : The size of the globalmap given in number of memory 
#                       pages. If this value is left unspecified, the default
#                       value DEF_CONFMAP_PG (currently = 2) is used.
#
#
# tables:
# ------
# point      : defines the named points in the plc. See further down for syntax.
# point_alias: defines aliases to the named points in the plc. See further 
#              down for syntax.
#
#
#
# The POINT table
# ---------------
# syntax:
# point name "full name" owner at offset[.bit] [length] [init init_value]
#
# where:
# point      = 'point' identifier
# name       = Name used to search for point in plc_pt_by_name()
# full name  = More extensive description of the point
#              This information is not loaded into the confmap of the plc
# owner      = Name of the module with write permission on the point
# at         = 'at' identifier
# offset     = location of word in the globalmap that holds the point's state
# bit        = the bit, in the word, that holds the point's state. This is 
#              optional, defaulting to 0.
# length     = the size in bits of the point. The point must not overflow
#              onto the next offset position (i.e. (bit + length) < 
#              (8*sizeof (u32)). The length is optional, defaulting to 32
#              if bit is not explicitly defined, and 1 otherwise.
# init       = 'init' identifier
# init_value = value the point will be initialised with
#
#
# the POINT_ALIAS table
# ---------------------
# syntax:
# point_alias name "full name" org_name [bit_ofs [length]]
#
# where:
# point_alias = 'point_alias' identifier
# name        = Name used to search for point in plc_pt_by_name()
# full name = More extensive description of the point
#             This information is not loaded into the confmap of the plc
# bit_ofs   = The first bit, of the original point, that this alias will 
#             reference. This is optional, defaulting to 0.
# length    = the size in bits of the point. The point must not overflow
#             outside the original point (i.e. (bit + length) < 
#             (length of org_name point). The length is optional, defaulting
#             to the length of the org_name point if the bit is explicitly
#             specified, and 1 otherwise.
#
# note:
# (1) offset, bit and length may be written in hexadecimal (0xF45A), 
#     octal (0172132) or decimal (62554) formats.  
#

[PLC]
confmap_key = 23   # if not present defaults to DEF_PLC_ID (currently 23)
globalmap_key = 0  # if not present defaults to random key (globalmap_key = 0)
sem_key = 0        # if not present defaults to random key (sem_key = 0)
confmap_pg = 2     # if not present defaults to DEF_CONFMAP_PG   (currently=2)
globalmap_pg = 2   # if not present defaults to DEF_GLOBALMAP_PG (currently=2)

[PLC]
point P0.0  "full name 0.0" TEST at  0.0 
point P0.1  "full name 0.1" TEST at  0.1 5
point P0.8  "full name 0.8" TEST at  0.8      # defaults to 0.8  1
point P0.3  "full name 0.3" TEST at  0.3      # ERROR! overlaps P0.1 
point P1.0  "full name 1.0" TEST at  1        # defaults to 1.0 32
point P2.0  "full name 2.0" TEST at  2    16  # defaults to 2.0 16  

point v1    v1	    TEST at 10  init 1
point v-1   v-1	    TEST at 11  init -1
point v+1   v+1	    TEST at 12  init +1
point v100  v100    TEST at 13  init 100
point v1.0  v1.0    TEST at 14  init 1.0
point v2.0  v2.0    TEST at 15  init 2.0
point v-2.0 v-2.0   TEST at 16  init -2.0
point v1e2  v1e2    TEST at 17  init 1e2
point vT    vT      TEST at 18  init TRUE
point vT5   vT5     TEST at 19  5  init TRUE
point vF    vF      TEST at 20  init FALSE

[PLC]
point_alias A0 "full name A0" P0.0            # defaults to P0.0 0 1
point_alias A1 "full name A1" P0.1            # defaults to P0.1 0 5
point_alias A2 "full name A2" P0.1 2          # defaults to P0.1 2 1
point_alias A3 "full name A3" P0.1 2 2
point_alias A4 "full name A4" P0.1 2 4        # ERROR! overflows outside of P0.1



[module_name]
#
#  P L C   r e l a t e d   v a l u e s
#  ===================================
#
#  PLC related values, specific to each module.
#
# name = value pairs:
# ------------------
# location = sss : defines how the module should access the shared plc 
#                  resources. Possible values are "local" for direct access, 
#                  and "isolate" for access through proxy process.
#                  This is the same as the command line --PLClocal and
#                  --PLCisolate arguments. The command line arguments take
#                  precedence over whatever is defined in the config file.
#                  If no value is specified by either method, the default
#                  DEF_PLC_LOCATION (currently = local) is used.
#
# privatemap_key = xxx: defines the key to use for the local map shared memory.
#                       Valid values go from 0..INT_MAX. A value of 0 has
#                       diferent meanings, depending on the location value.
#                       For local access, a value of 0 implies the use of malloc
#                       to allocate memry for the local map. For isolate access,
#                       a random key is used for the local map shared memory.
#                       The default value for every access method is 
#                       DEF_LOCALMAP_KEY (currently = 0)
#                       NOTE: in the source code the localmap is also sometimes
#                       refered to as the private map. This is something that 
#                       must be corrected...
