#
# matplc.conf - configuration file
#

[PLC]
point 		L	"light"        Chaser at 0   4


# Configure the cif module, that will copy the
#  matplc points to the cif I/O card.
[cif]

# The cif card BoardId
#
# NOTE: This is the id the cif device driver (i.e. cif kernel module)
#       uses to identify the card we want the cif module to use.
# Extended explanation:
#   The cif module of the MatPLC does not directly access the cif card.
#   It does so through a kernel module (i.e. a device driver) specific
#   for cif cards. When this module is loaded, it finds every PCI based
#   cif card automatically. Cards on
#   the ISA bus have to be explicitly specified on the command line when
#   the device driver is loaded. Each card that the device driver
#   can correctly access is given a unique number from 0..3
#   Since this module uses the device driver to control the cif card,
#   what the module needs is the number the device criver gave the cif card
#   we want the module to access.
BoardID = 0       # defaults to 0


# The DPM (Dual Port Memory) Size, in kBytes
#
# Extended Explanation:
#   This is the size of the DPM on the card the module will be using.
#   Actually this parameter is not very important, this is basically just to
#   allow the cif mofule to verify at configuration time if any plc point
#   will be mapped onto an offset that falls outside the card's process
#   image.
#   The In and Out process images are disjoint, and do not overlap.
#   The size (in bytes) of each process image depends on the DPM size
#   (in kBytes) and is given by:
#   ((DPMsize * 1024) - 1024) / 2
#   At runtime the module will verify if the card that it is using really
#   does have a DPM the size the user says it should have.
DPMsize = 8   # defaults to 8. Other possible values seem to be 2 (kBytes)


# Maximum timeout when trying to access the cif card.
# Value represents ms
# Default is 100 (ms)
# 0 means no timeout
timeout = 100



#  Digital I/O available on the cif card
#
# node format
# map [inv | invert] {in | out} <io_addr> <matplc point>
#
#  inv    -> invert the value being read from/writen to physical IO
#  invert -> invert the value being read from/writen to physical IO
#
#  in  -> copy from the input process image to the matplc point
#  out -> copy the state of the matplc point to the outout process image
#
#  <io_addr>  : location in the process image
#               <offset>[.<bit>]
#
#  <offset>   : [0..process image size]
#  <bit>      : [0..7]
#
# NOTE:
#   Every number may also be given in hexadecimal format,
#   e.g. 0x3A is equivalent to 58
#
# NOTE:
#  MatPLC points larger than 1 bit will be mapped starting at the
#  given <offset>.<bit> location, and carry on from there. Note that
#  this means that the data of a matplc point may also fall onto
#  the subsequent bytes of the process image, if required.
#  E.g.:
#  map out 0.0 a_pplc_1bit_point
#    the plc point will only fall on 0.0
#
#  map out 1.0 a_pplc_16bit_point
#    the plc point will fall on 1.0 to 2.7
#
#  map out 3.0 a_pplc_32bit_point
#    the plc point will fall on 3.0 to 6.7
#
#  map out 10.4 a_pplc_8bit_point
#    the plc point will fall on 10.4 to 11.3
#
#  map out 20.6 a_pplc_32bit_point
#    the plc point will fall on 20.6 to 24.5
#

map out 0.0 L

