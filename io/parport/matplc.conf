# This is the plc config file.
#

[PLC]

# outputs to be driven or need to be driven on by other modules
# eg. TEST
#
# inputs from the feild must be driven by the module parport
#

point	D0_pt	"parallel port D0"	TEST	at 0.0
point	D1_pt	"parallel port D1"	TEST	at 0.1
point	D2_pt	"parallel port D2"	TEST	at 0.2
point	D3_pt	"parallel port D3"	TEST	at 0.3
point	D4_pt	"parallel port D4"	TEST	at 0.4
point	D5_pt	"parallel port D5"	TEST	at 0.5
point	D6_pt	"parallel port D6"	TEST	at 0.6
point	D7_pt	"parallel port D7"	TEST	at 0.7




# Configure the parport module, that will copy the
#  matplc points to the parallel port.
[parport]

# The parallel ports base address.
io_addr = 0x378   # 0x378 is the default if no io_addr is specified.
                  # You may also like to try 0x278 if the first doesn't work

# If you prefer to go though the kernel driver, then specify the device file
dev_file = /dev/plc_parport0

# NOTE: If both of the above methods of accessing the parallel port are
#       configured, then the kernel driver will be used. Only if this method
#       fails will it fall back to the direct access mode, using the specified
#       (or default) io base address.



#  Digital I/O available on the parallel port
#
#  Bitmap:
#  Data In/Out     D0-D7   8 LS TTL outputs/inputs (pins 2-9 respectively)
#  Status In       S3-S7   5 LS TTL inputs (pins 15/13/12/10/11 respectively)
#  Control In/Out  C0-C3   4 TTL Open Collector outputs/inputs (pins 1/14/16/17)
#
#  NOTE: Some of the S and C bits are inverted by the parallel port hardware.
#        We re-invert all these bits so that this library presents a coherent
#        positive logic interface.
#
#  NOTE: C0-C3 are usually used solely as outputs, but since they are
#        open collector, they can be put into high impedance state by writing
#        1 to every output. In this state, these lines may be used as inputs!
#        That is why we inhibit any writes to this register while it is
#        in input mode.
#	 Note that not all PC hardware allows reading the true input value
#	 of this register when the outputs are set to high impedance, so this
#        may not always work.
#        Note that this may also not work if the access to the parallel port
#        is made through the kernel, instead of going direct by reading io ports
#        It is guaranteed not to work on a PC style hardware and if using kernel
#        access because the kernel pc parallel port driver does not support
#        reading the true inputs of this register. It merely hands out a copy
#        of the most recent write.
#


# define the direction {in | out} the D register should use
Ddir = out

# define the direction {in | out} the C register should use
Cdir = in

# The S register can only be used as input!

# NOTE: If the direction of a register is not explicitly specified, it
#       will be inferred from the direction of the first point mapping
#       in which it appears.


# node format
# map [inv | invert] {in | out} <io_addr> <matplc point>
#
#  inv    -> invert the value being read from/writen to physical IO
#  invert -> invert the value being read from/writen to physical IO
#
#  in  -> copy the state of the parallel port register to the matplc point
#  out -> copy the state of the matplc point to the parallel port register
#
#  <io_addr>  : address of physical IO. For the parallel port, use the syntax
#               <register>.<bit>
#  <register> : one of C, D or S
#  <bit>      : [0..7] for D
#               [0..3] for C
#               [0..4] for S
#
# NOTE: all bits of the same register must use the same direction (in or out)


map out D.0 D0_pt
map out D.1 D1_pt
map out D.2 D2_pt
map out D.3 D3_pt
map out D.4 D4_pt
map out D.5 D5_pt
map out D.6 D6_pt
map out D.7 D7_pt
